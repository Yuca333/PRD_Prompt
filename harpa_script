meta:
  title: v4.0 Complete - Site to PRD to Lovable to Data
  description: Analyzes site, generates PRD and Lovable prompt, auto-deploys
  category: User
steps:
  - type: say
    message: Starting v4.0 automation
  - type: ask
    param: siteUrl
    message: Enter site URL
    default: ''
  - type: say
    message: Opening ChatGPT for image discovery
  - type: navigate
    url: https://chatgpt.com/
    waitForIdle: true
  - type: wait
    timeout: 8000
    for: idle
  - type: say
    message: Prompt 0 - Image Extraction
  - type: wait
    timeout: 2000
    for: idle
  - type: js
    code: >
      const url = args.siteUrl;

      const prompt = `2 Image Task
      ───────────────────────────────────────────────────────────────────

      1. Visit the target URL given at the **end of this prompt**.
      2. Extract 3–5 most important marketing images (Logo, Hero, Team, Product).
      3. Output ONLY one of the two blocks below.

      IMAGE INTEGRATION FOR PRD
      ═══════════════════════════════════════════════════════════════════

      <thinking_mode>
      You MUST aggressively try to discover marketing images before concluding “no images”.

      The “target URL” is the URL on the last line of this prompt. Use it for all steps below.

      FETCH & RETRY STRATEGY

      1. Start by fetching the page at the target URL exactly as written on the last line of this prompt.
      2. If the target URL has no scheme, assume https:// and prepend it.
      3. Derive HOST_ONLY as the domain part of the target URL (e.g. if the target URL is https://www.vogt-hans.de/inhalt-Dateien/image002.jpg, then HOST_ONLY is vogt-hans.de).
      4. If the initial fetch fails for any reason (network, TLS, timeout, access, decoding error, etc.), try in this order (if different from the original):
      • https:// + HOST_ONLY
      • https://www. + HOST_ONLY
      • http:// + HOST_ONLY
      • http://www. + HOST_ONLY

      Treat any successfully fetched HTML document from this domain as a candidate for parsing (home page, root, or redirected landing page).

      IMAGE DISCOVERY STRATEGY (apply to each successfully fetched HTML page)
      Use ALL of the following methods:
      • METHOD 1 (HTML images): Scan <img>, <picture>, <source> for src, srcset, data-src.
      • METHOD 2 (CSS backgrounds): Scan inline styles and linked stylesheets for background-image, background, or custom properties that contain image URLs.
      • METHOD 3 (Meta images): Check <meta property="og:image">, <meta name="twitter:image">, and similar.
      • METHOD 4 (Size/role cues): Prefer larger images, images in header/hero/slider sections, and images near main headings or marketing copy.

      FILTERING & PRIORITY
      Prioritize in this order:

      1. Company logo (header/footer or clearly brand-mark).
      2. Hero/main visual (large, above the fold, central).
      3. Service/product images (1–2 strongest visuals).
      4. Team/people photos (if prominent as part of marketing).

      EXCLUDE:
      • Icons smaller than ~50px, social media logos, purely decorative flourishes, menu icons, tiny bullets.

      DECISION PROTOCOL (STRICT)
      • IF you successfully identify ANY valid marketing image (logo, hero, service/product, team) using the above methods on ANY successfully loaded page from the domain →
      → You MUST output BLOCK A.

      • OTHERWISE (including ANY of the following):
      – Only tiny icons/social logos found,
      – Page(s) are not accessible or not parseable (network error, TLS error, encoding/decoding issues, timeout, access forbidden, unknown content type),
      – HTML loads but no suitable marketing images can be confidently identified,

      → You MUST output BLOCK B.

      So BOTH:
      • “Truly no marketing images” AND
      • “Technical failure or inability to extract marketing images”

      map to the same fallback: BLOCK B.

      CRITICAL OUTPUT RULES
      • Do NOT output “BLOCK A” or “BLOCK B” labels or any headers.
      • Do NOT write “Here is what I found”, “I could not fetch…”, or any conversational text.
      • Do NOT explain errors, reasons, or this decision logic.
      • Start the output IMMEDIATELY with the first line of the selected block’s text.
      • The output must be raw text ready for copy-pasting to another AI.
      </thinking_mode>

      IMAGE PRIORITY (Find in this order)
      ───────────────────────────────────────────────────────────────────

      1. Company logo (header/footer)
      2. Hero/main visual (large, above fold, central)
      3. Service/product images (1–2 key visuals)
      4. Team/people photos (if prominent)

      EXCLUDE: Icons (<50px), social logos, decorative graphics, menu images.

      EXTRACTION STRATEGY (Use ALL methods)
      ───────────────────────────────────────────────────────────────────
      METHOD 1: Standard Image Tags (src, srcset, data-src)
      METHOD 2: CSS Background Images (computed styles)
      METHOD 3: Picture Elements (<source> tags)
      METHOD 4: Meta Tags (og:image, twitter:image)

      [URL Normalization: Prepend https:// if needed. Use absolute URLs. Remove params unless vital.]

      ═══════════════════════════════════════════════════════════════════
      BLOCK A: (Use if Images Found)
      ═══════════════════════════════════════════════════════════════════
      Integrate the following images into the design In way they would fit best for the business and the PRD.
      Upgrade the PRD if necessary.

      1. Logo: [URL] -[Brief visual description]
      2. Hero: [URL] - [Brief visual description]
      3. Service: [URL] - [Brief visual description]
      etc

      PRD INTEGRATION Suggestions:

      HERO IMAGE STRATEGY Suggestions:
      • Primary Image: [URL]
      • Treatment: [e.g., "Full background at 60% opacity with slate-900 overlay"]
      • Mobile: [e.g., "Center-crop focus on subject, no parallax"]

      • Color Suggestions: Change Primary Color to [Hex/Tailwind] to match image tones.

      ADDITIONAL ASSETS:
      • Services: Use [URL] for [Specific Service Name].
      • About/Team: Use [URL] for "About Us" section.
      Update your Visual Design concept with these suggestions. But you make the final call for the overall Design concept based on all the information you have available

      ═══════════════════════════════════════════════════════════════════
      BLOCK B: (Use if NO Images Found OR technical extraction failed) //output it as written below
      ═══════════════════════════════════════════════════════════════════
      DESIGN OPTIMIZATION PROMPT
      For AI Implementation via Lovable.dev
      <thinking_mode>
      Deep critical analysis required. Challenge every design choice.
      </thinking_mode>
      SELF-CRITIQUE
      Rate your PRD design: [X/10]
      If not 10/10, identify gaps:

      * Visual Concept: Truly business-specific or generic rebranded?
      * CSS Strategy: Did you specify effects lovable.dev excels at (Tailwind utilities, shadcn/ui, backdrop-blur, mesh gradients) or guess?
      * Spatial Design: Optimized for React component architecture?
      * Hero: Actually implementable with production quality?
      Deep Analysis Questions:

      1. Does each element serve THIS business's unique positioning?
      2. Can lovable.dev render this at boutique-level quality?
      3. What better approach haven't I considered?
      LOVABLE.DEV TECHNICAL CHECK
      Verify against capabilities:
      ✅ Use These: Tailwind CSS utilities, shadcn/ui components, CSS gradients, backdrop-blur, box-shadow, smooth transitions, responsive breakpoints, React composition
      ⚠️ Avoid: Complex custom animations, experimental CSS, external animation libraries
      Output:

      * Effects to keep: [List]
      * Effects to replace: [List with stable alternatives]
      * Missing opportunities: [Lovable-optimized patterns you didn't use]
      REFINED DESIGN
      Based on critique, output ONLY changed sections:
      VISUAL CONCEPT V2:
      [Improved concept if needed, or justify why original is optimal]
      LOVABLE-OPTIMIZED IMPLEMENTATION:
      * Exact Tailwind classes for key effects
      * Specific shadcn/ui components
      * Gradient approach (CSS mesh/linear)
      * Mobile-first breakpoint strategy
      HERO REDESIGN:
      [Component structure + specific visual effect implementation lovable.dev handles flawlessly]

      Final Output: Updated PRD sections with lovable.dev-specific optimizations.
      ═══════════════════════════════════════════════════════════════════

      Based on the strict DECISION PROTOCOL

      output only either Block A or Block B, nothing else.

      TARGET URL: ${url}

      _________________________`;

      console.log('Prompt:', prompt);


      const selectors = ['textarea', 'div[contenteditable="true"]', '[role="textbox"]'];

      let input = null;

      for (const sel of selectors) {
        const el = document.querySelector(sel);
        if (el && window.getComputedStyle(el).display !== 'none') {
          input = el;
          console.log('Found input:', sel);
          break;
        }
      }


      if (!input) {
        console.error('No input found');
        return { error: 'Input not found', success: false };
      }


      function setReactValue(element, value) {
        if (element.tagName === 'TEXTAREA') {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
          setter.call(element, value);
        } else {
          element.textContent = value;
        }
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }


      input.focus();

      await new Promise(r => setTimeout(r, 500));


      try {
        const success = document.execCommand('insertText', false, prompt);
        if (!success) {
          console.log('execCommand failed, using setReactValue');
          setReactValue(input, prompt);
        }
      } catch (e) {
        console.log('execCommand error:', e);
        setReactValue(input, prompt);
      }


      return { success: true, promptLength: prompt.length };
    args: siteUrl
    param: paste0
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const buttonSelectors = [
        'button[type="submit"]',
        'button[aria-label*="Submit"]',
        'button[aria-label*="Send"]'
      ];


      for (const sel of buttonSelectors) {
        const buttons = Array.from(document.querySelectorAll(sel));
        for (const btn of buttons) {
          const style = window.getComputedStyle(btn);
          if (style.display !== 'none' && !btn.disabled) {
            console.log('Clicking submit button');
            btn.click();
            return { success: true, method: 'button' };
          }
        }
      }


      const input = document.querySelector('textarea, [contenteditable="true"], [role="textbox"]');

      if (!input) return { error: 'Input lost' };


      input.focus();


      const form = input.closest('form');

      if (form) {
        console.log('Submitting form');
        form.requestSubmit();
        return { success: true, method: 'form' };
      }


      console.log('Using Enter key');

      input.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        bubbles: true,
        cancelable: true
      }));


      return { success: true, method: 'keyboard' };
    param: submit0
  - type: say
    message: Waiting for response 0
  - type: wait
    timeout: 5000
    for: idle
  - type: js
    code: |
      const maxWait = 600;
      const check = 3;
      let waited = 0;
      while (waited < maxWait) {
        const stop = document.querySelector('button[aria-label*="Stop"]');
        const inputSelectors = ['textarea[placeholder="Ask anything..."]', 'textarea', 'div[contenteditable="true"]', '[role="textbox"]'];
        let input = null;
        for (const sel of inputSelectors) {
          input = document.querySelector(sel);
          if (input) break;
        }
        if (!stop && input) {
          return { finished: true, waitedSeconds: waited };
        }
        await new Promise(r => setTimeout(r, check * 1000));
        waited += check;
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: wait0
  - type: say
    message: Response 0 complete
  - type: wait
    timeout: 3000
    for: idle
  - type: say
    message: Opening Perplexity
  - type: navigate
    url: https://www.perplexity.ai/
    waitForIdle: true
  - type: wait
    timeout: 8000
    for: idle
  - type: say
    message: Prompt 1 - Business Intelligence
  - type: wait
    timeout: 2000
    for: idle
  - type: js
    code: >
      const url = args.siteUrl;

      const prompt = 'You are a senior business intelligence analyst
      specializing in comprehensive website analysis for premium redesign
      projects. TARGET WEBSITE: ' + url + ' MISSION: Extract COMPLETE website
      intelligence to enable world-class redesign. This is a paid client
      engagement - extract everything needed to preserve their business voice
      and competitive positioning. EXTRACTION PROTOCOL: Browse ALL major pages
      systematically (Homepage, Services, About, Contact, Testimonials,
      Pricing). BUSINESS INTELLIGENCE: 1. Business Identity - Official name,
      tagline, industry sector (specific), years in business, geographic service
      areas. 2. Services/Offerings (CRITICAL) - For EACH service: name, complete
      description word-for-word, benefits, pricing if stated, target customers.
      3. Value Propositions - Why choose this business, what makes them unique,
      competitive advantages, problems they solve. 4. Target Audience - Ideal
      customers, demographics, pain points addressed. COMPLETE CONTENT
      EXTRACTION (exact text, do not summarize): 1. Homepage - Hero headline
      exact text, subheadline exact text, main CTA, every section heading and
      body text. 2. About/Company - Complete story word-for-word, mission,
      founder info, team bios complete text, achievements. 3. Testimonials -
      Complete customer quotes exact words, names, titles, locations. 4.
      Credentials - All certifications, licenses, awards, memberships, years
      experience. 5. Contact Info - Phone, email, physical address, business
      hours complete schedule, service areas, social media. VISUAL ASSETS:
      Extract 2-6 most important image URLs (hero image, logo, key service
      images, team photo). Note primary brand colors if identifiable, overall
      visual style. CURRENT WEBSITE ASSESSMENT: Identify 4-5 CRITICAL issues
      with specific examples (outdated design, poor mobile, unclear navigation,
      weak CTAs, unprofessional layout). BRAND VOICE ANALYSIS: Tone
      (professional/casual/technical), writing style, language level, key
      phrases used, overall personality. OUTPUT FORMAT: Present as WEBSITE
      INTELLIGENCE EXTRACTION REPORT with TARGET WEBSITE, EXTRACTION DATE, then
      all sections. Include EXTRACTION COMPLETENESS ASSESSMENT with content
      coverage, gaps identified, confidence level. CRITICAL: Extract complete
      text, do NOT summarize. Preserve exact wording. Include ALL services with
      full descriptions. Capture authentic brand voice.';


      console.log('Prompt:', prompt);


      const selectors = ['textarea', 'div[contenteditable="true"]',
      '[role="textbox"]'];

      let input = null;

      for (const sel of selectors) {
        const el = document.querySelector(sel);
        if (el && window.getComputedStyle(el).display !== 'none') {
          input = el;
          console.log('Found input:', sel);
          break;
        }
      }


      if (!input) {
        console.error('No input found');
        return { error: 'Input not found', success: false };
      }


      function setReactValue(element, value) {
        if (element.tagName === 'TEXTAREA') {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
          setter.call(element, value);
        } else {
          element.textContent = value;
        }
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }


      input.focus();

      await new Promise(r => setTimeout(r, 500));


      try {
        const success = document.execCommand('insertText', false, prompt);
        if (!success) {
          console.log('execCommand failed, using setReactValue');
          setReactValue(input, prompt);
        }
      } catch (e) {
        console.log('execCommand error:', e);
        setReactValue(input, prompt);
      }


      return { success: true, promptLength: prompt.length };
    args: siteUrl
    param: paste1
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const buttonSelectors = [
        'button[type="submit"]',
        'button[aria-label*="Submit"]',
        'button[aria-label*="Send"]'
      ];


      for (const sel of buttonSelectors) {
        const buttons = Array.from(document.querySelectorAll(sel));
        for (const btn of buttons) {
          const style = window.getComputedStyle(btn);
          if (style.display !== 'none' && !btn.disabled) {
            console.log('Clicking submit button');
            btn.click();
            return { success: true, method: 'button' };
          }
        }
      }


      const input = document.querySelector('textarea, [contenteditable="true"],
      [role="textbox"]');

      if (!input) return { error: 'Input lost' };


      input.focus();


      const form = input.closest('form');

      if (form) {
        console.log('Submitting form');
        form.requestSubmit();
        return { success: true, method: 'form' };
      }


      console.log('Using Enter key');

      input.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        bubbles: true,
        cancelable: true
      }));


      return { success: true, method: 'keyboard' };
    param: submit1
  - type: say
    message: Waiting for response 1
  - type: wait
    timeout: 5000
    for: idle
  - type: js
    code: |
      const maxWait = 600;
      const check = 3;
      let waited = 0;
      while (waited < maxWait) {
        const stop = document.querySelector('button[aria-label*="Stop"]');
        const inputSelectors = ['textarea[placeholder="Ask anything..."]', 'textarea', 'div[contenteditable="true"]', '[role="textbox"]'];
        let input = null;
        for (const sel of inputSelectors) {
          input = document.querySelector(sel);
          if (input) break;
        }
        if (!stop && input) {
          return { finished: true, waitedSeconds: waited };
        }
        await new Promise(r => setTimeout(r, check * 1000));
        waited += check;
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: wait1
  - type: say
    message: Response 1 complete
  - type: js
    code: |
      await new Promise(r => setTimeout(r, 1000));
      return window.location.href;
    param: finalChatUrl
  - type: wait
    timeout: 3000
    for: idle
  - type: say
    message: Prompt 2 - PRD
  - type: js
    code: >
      const prompt = 'You are a senior web strategist and design consultant
      specializing in award-winning website redesigns for small businesses.
      MISSION: Review the Website Intelligence Extraction Report you just
      created, fill any critical gaps, then research and specify award-winning
      design direction. PHASE 1 GAP ANALYSIS (20 percent): Review extraction for
      missing info: Complete service descriptions, pricing, full contact info,
      company background, team bios, credentials, testimonials, geographic
      coverage. IF GAPS EXIST: Return to original website and extract missing
      information. Document as ADDITIONAL EXTRACTION with category, complete
      text, source page. PHASE 2 AWARD-WINNING DESIGN RESEARCH (80 percent):
      PRIMARY FOCUS: Visual excellence and stunning UX. NOT priorities: SEO,
      performance, accessibility. Search for best-in-class design: best industry
      website design 2024, award winning industry websites, industry design
      inspiration, luxury industry web design, premium small business design.
      ANALYZE 5-8 EXEMPLARY WEBSITES documenting: 1. Visual Design Excellence -
      Layout grid system white space, color palette contrast, typography
      hierarchy, photography style, visual mood. 2. Stunning UI Elements - Hero
      composition CTA placement, card designs shadows hover, button styles
      micro-interactions, navigation patterns, form design, section transitions.
      3. Premium UX - Service presentation, trust signal integration, social
      proof display, contact CTA strategy, content organization. 4. Interactive
      Dynamic - Scroll animations, hover states, image treatments parallax,
      video integration, transitions. 5. Mobile Patterns - Touch-friendly
      navigation, content prioritization, mobile interactions. OUTPUT DESIGN
      BENCHMARK RESEARCH with industry, exemplary websites analyzed, key design
      patterns for visual layout color typography imagery, UX navigation content
      CTAs trust, mobile standards, conversion practices. DESIGN DIRECTION
      SPECIFICATIONS: 1. Visual Aesthetic - Overall mood, design philosophy,
      visual personality. 2. Color Strategy - Primary Secondary Accent colors
      with hex codes and rationale for premium feel. 3. Typography System -
      Heading font Body font with pairing rationale, size scale, weight
      variations. 4. Layout Spacing - Grid system, white space philosophy,
      section spacing, content width, mobile adaptation. 5. Photography Imagery
      - Hero style, treatment, overlays, service images, team photos. 6. UI
      Components - Buttons Primary Secondary Ghost specs, Cards service
      testimonial team treatment, Forms input labels submit, Navigation desktop
      mobile. 7. Interactive Elements - Micro-interactions, scroll animations,
      transitions, loading states. 8. Homepage Architecture - Hero Section
      composition impact CTA, Services layout visual interaction, Trust
      testimonial credential authority, Contact prominence form options. 9.
      Mobile Priorities - Touch targets thumb-friendly content navigation fast.
      10. Design Differentiation - Unique visual elements standing out. DESIGN
      CONFIDENCE ASSESSMENT with visual impact rating, design modernity, brand
      fit, implementation feasibility. Combine Gap Analysis and Design Research
      into comprehensive deliverable.';


      console.log('Prompt:', prompt);


      const selectors = ['textarea', 'div[contenteditable="true"]',
      '[role="textbox"]'];

      let input = null;

      for (const sel of selectors) {
        const el = document.querySelector(sel);
        if (el && window.getComputedStyle(el).display !== 'none') {
          input = el;
          console.log('Found input:', sel);
          break;
        }
      }


      if (!input) {
        console.error('No input found');
        return { error: 'Input not found', success: false };
      }


      function setReactValue(element, value) {
        if (element.tagName === 'TEXTAREA') {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
          setter.call(element, value);
        } else {
          element.textContent = value;
        }
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }


      input.focus();

      await new Promise(r => setTimeout(r, 500));


      try {
        const success = document.execCommand('insertText', false, prompt);
        if (!success) {
          console.log('execCommand failed, using setReactValue');
          setReactValue(input, prompt);
        }
      } catch (e) {
        console.log('execCommand error:', e);
        setReactValue(input, prompt);
      }


      return { success: true, promptLength: prompt.length };
    param: paste2
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const buttonSelectors = [
        'button[type="submit"]',
        'button[aria-label*="Submit"]',
        'button[aria-label*="Send"]'
      ];


      for (const sel of buttonSelectors) {
        const buttons = Array.from(document.querySelectorAll(sel));
        for (const btn of buttons) {
          const style = window.getComputedStyle(btn);
          if (style.display !== 'none' && !btn.disabled) {
            console.log('Clicking submit button');
            btn.click();
            return { success: true, method: 'button' };
          }
        }
      }


      const input = document.querySelector('textarea, [contenteditable="true"],
      [role="textbox"]');

      if (!input) return { error: 'Input lost' };


      input.focus();


      const form = input.closest('form');

      if (form) {
        console.log('Submitting form');
        form.requestSubmit();
        return { success: true, method: 'form' };
      }


      console.log('Using Enter key');

      input.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        bubbles: true,
        cancelable: true
      }));


      return { success: true, method: 'keyboard' };
    param: submit2
  - type: say
    message: Waiting for response 2
  - type: wait
    timeout: 5000
    for: idle
  - type: js
    code: |
      const maxWait = 600;
      const check = 3;
      let waited = 0;
      while (waited < maxWait) {
        const stop = document.querySelector('button[aria-label*="Stop"]');
        const inputSelectors = ['textarea[placeholder="Ask anything..."]', 'textarea', 'div[contenteditable="true"]', '[role="textbox"]'];
        let input = null;
        for (const sel of inputSelectors) {
          input = document.querySelector(sel);
          if (input) break;
        }
        if (!stop && input) {
          return { finished: true, waitedSeconds: waited };
        }
        await new Promise(r => setTimeout(r, check * 1000));
        waited += check;
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: wait2
  - type: say
    message: Response 2 complete
  - type: wait
    timeout: 3000
    for: idle
  - type: say
    message: Prompt 3 - Lovable Phase 1
  - type: js
    code: >
      const prompt = '# LOVABLE.DEV PROMPT FRAMEWORK v3.0\n## AI-to-AI Prompt
      Generator for Award-Winning Landing Pages\n\n---\n\n## YOUR ROLE\n\nYou
      are a prompt engineer specializing in generating optimized Lovable.dev
      prompts (Max 2600 words). Your task is to transform business information
      into a comprehensive, research-backed prompt that Lovable.dev\'s Claude AI
      will use to generate award-winning landing page code.\n\n**You do NOT
      generate the landing page code itself. You generate the PROMPT for
      Lovable.dev.**\n\n---\n\n## TWO-PHASE STRATEGY\n\n**Phase 1** (Output
      now): Core structure, layout, conversion strategy (1,800-2,500
      words)\n**Phase 2** (Output only when requested): Advanced visual
      enhancements (1,800-2,500 words)\n\nPlan both phases strategically, but
      output only Phase 1 unless specifically asked for Phase 2.\n\n---\n\n##
      PHASE 1: PLANNING PROCESS\n\n### 1. Extract & Research Business
      Context\n\nRead business information from the conversation. If critical
      details are missing, use web_search to gather:\n- Company positioning,
      unique value proposition, visual identity\n- Target audience demographics,
      device usage patterns, pain points\n- Competitor design patterns for
      differentiation opportunities\n- Industry-specific trust signals and
      conversion best practices\n\nDocument your understanding:\n- **Company**:
      [Name, industry, core offering]\n- **Audience**: [Specific demographic +
      psychographic + use case]\n- **Goal**: [Measurable outcome - "Generate X
      demos monthly" not "get leads"]\n- **Device Priority**: [Mobile-first /
      Desktop-primary with industry justification]\n\n### 2. Define Visual
      Strategy\n\nChoose aesthetic anchor based on brand personality:\n-
      **Design Movement Mashup**: "Brutalism meets Scandinavian minimalism"\n-
      **Brand Comparison**: "Stripe\'s technical precision with Notion\'s
      warmth"\n- **Sensory Description**: "Sunlit Scandinavian cafe - clean
      lines, natural warmth, focused calm"\n\nEstablish hierarchy intent:\n-
      **Primary (60% attention)**: [Hero CTA / Product showcase / Value prop]\n-
      **Secondary (30%)**: [Features / Social proof / Trust signals]\n-
      **Tertiary (10%)**: [Footer / Navigation / Fine print]\n\nDefine color
      strategy using emotional language:\n- **Base**: "Nordic palette with soft
      grays and warm woods" (NOT hex codes)\n- **Accent**: "Oxidized copper" or
      "Forest sage" (single color for conversion points)\n- **Application**:
      "70% neutral space, accent exclusively for CTAs"\n\n### 3. Identify Core
      Constraints\n\nSelect 3-5 positive constraints specific to this
      business:\n1. **White Space Strategy**: 80px section padding, 60px CTA
      isolation buffer\n2. **Typography Hierarchy**: 3-tier system (48-72px
      hero, 32-40px sections, 16-18px body)\n3. **Asymmetric Layout**: 60/40
      splits, magazine-style composition, avoid centered balance\n4. **Color
      Discipline**: 3 colors max + neutrals, accent only for conversion
      elements\n5. **Mobile-First Touch**: 44x44px minimum touch targets,
      thumb-zone CTAs\n\n### 4. Plan Image Integration\n\nExtract image URLs
      from conversation. Plan strategic placement:\n- **Hero**: Background or
      split-screen composition with overlay for text readability\n- **Social
      Proof**: Team photos, customer logos, authentic testimonials (not
      stock)\n- **Features**: Supporting visuals, before/after comparisons,
      process illustrations\n- **Trust Signals**: Certification badges, team
      headshots, facility photos\n\nSpecify: `Use provided image: [URL] for
      [section] positioned [layout description]`\n\n### 5. Allocate Content to
      Phases\n\n**Phase 1 Focus**:\n- Page structure and layout\n- Conversion
      strategy and CTA hierarchy\n- Core visual direction and constraints\n-
      Functional requirements and technical stack\n- Image placement
      strategy\n\n**Phase 2 Reserve** (don\'t output yet):\n- Framer Motion
      animations (scroll reveals, entrance effects, parallax)\n-
      Micro-interactions (hover states, button morphs, cursor effects)\n- Custom
      illustrations and SVG graphics\n- Premium polish (textures, gradients, 3D
      depth)\n- Advanced storytelling elements\n\n---\n\n## PHASE 1: OUTPUT
      FORMAT\n\nGenerate a complete Lovable.dev prompt following this
      structure:\n\n```\nCreate a [aesthetic description] landing page for
      [Business], a [industry] business serving [specific target
      audience].\n\nBUSINESS CONTEXT\n- Company: [Name and core offering]\n-
      Audience: [Specific demographic with context and pain points]\n- Goal:
      [Measurable conversion objective]\n- Device Priority:
      [Mobile-first/Desktop-primary with justification]\n\nDESIGN
      DIRECTION\nAesthetic: [Design movement mashup or sensory
      description]\nHierarchy: Primary (60%) [element], Secondary (30%)
      [elements], Tertiary (10%) [elements]\nColors: Base [contextual
      description], Accent [single color name], Application [distribution
      strategy]\n\nCORE CONSTRAINTS\n1. [Positive constraint with specific
      measurement]\n2. [Positive constraint with specific measurement]\n3.
      [Positive constraint with specific measurement]\n4. [Optional 4th
      constraint]\n5. [Optional 5th constraint]\n\nTECHNICAL STACK\n- React 18 +
      TypeScript\n- Tailwind CSS v4 (use @theme in globals.css, NOT
      tailwind.config.js)\n- shadcn/ui components: [Auto-Form for forms, Dialog
      for modals, DataTable if needed]\n- Framer Motion for animations\n-
      Advanced Tailwind: backdrop-blur-sm, group-hover:, custom @keyframes,
      motion-safe: prefix\n\nRESPONSIVE STRATEGY\n- Base: 375px mobile (no
      prefix)\n- sm: 640px tablet adjustments\n- lg: 1024px desktop asymmetric
      grids\n- xl: 1280px enhanced spacing\n\nIMAGE INTEGRATION\n[For each
      provided image URL:]\n- Use [URL] in [section]: [specific placement and
      layout treatment]\n- Example: "Use [hero-image.jpg] as hero background
      with 40% opacity overlay for text readability"\n\nPAGE STRUCTURE\n\nHero
      Section (Above Fold Priority)\nLayout: F-pattern flow, 60/40 asymmetric
      split on desktop, single column mobile\nContent:\n- Headline:
      [Benefit-focused, specific - "Close Deals 3x Faster" NOT "Best
      Solution"]\n- Subheadline: [One sentence explaining mechanism]\n- Primary
      CTA: 52px height, accent color, first-person copy ("Start My Free Trial"),
      includes benefit reminder\n- Trust Signal: [Specific metric - "2,847
      companies" OR security badge]\nVisual: [Image placement strategy with
      overlay/positioning specs]\nSpacing: 60px CTA isolation, generous white
      space channel funneling to action\n\nSocial Proof Section\nLayout:
      Featured testimonial (60% visual weight) + supporting elements
      (40%)\nContent:\n- Featured: Real photo, full name, company logo, specific
      metric ("Increased leads 127% in 90 days")\n- Supporting: "Join 4,847
      [audience] who [outcome] in [timeframe]"\n- Client Logos: 6-8 max,
      grayscale for consistency\n- Industry Trust Markers: [Certifications,
      years, case results, guarantees]\nVisual: [Testimonial image placement,
      logo grid treatment]\n\nFeatures/Services Section\nLayout: Asymmetric
      3-column grid (avoid symmetrical balance)\nEach Feature:\n- Icon: 48px,
      simple geometric (NO emojis)\n- Headline: 20px, benefit-focused ("Never
      Miss Follow-Up" NOT "Email Automation")\n- Bullets: 3 max, bold key
      phrases\nInteractions: Cards scale 1.02 on hover (0.3s ease), shadow
      increase\nVisual: [Feature illustration or screenshot placement if images
      provided]\n\nCall-to-Action Section\nCTA Hierarchy:\n1. Primary: 56px
      height, solid accent, first-person copy with benefit, 80px isolation\n2.
      Secondary: 44px outline style, supporting action\n3. Tertiary: Text link
      only\nForm Design (if lead generation):\n- Progressive disclosure:
      Multi-step (email → details → contact)\n- Progress indicator: Visual bar
      "Step 1 of 3"\n- Fields: 48px height, 16px font, labels above (not
      placeholder-only)\n- Trust micro-copy: "We never share your email" with
      lock icon\n- Inline validation: Checkmark on valid format\nMobile: Sticky
      bottom bar (60px) after 50% scroll, primary CTA + offer
      reminder\n\nFooter\nMinimal visual weight, 30% opacity colors, 14px
      text\nContent: Company info, privacy/terms, social links, newsletter
      signup (tertiary priority)\n\nDESIGN EXCELLENCE\n\nWhite Space: 80px
      section padding desktop, 60px mobile, 8px grid system
      (16/24/32/40/48/64/80 multiples)\n\nMicro-Interactions: (200-400ms
      duration)\n- Buttons: Scale 1.05 hover, 0.95 active, 0.3s ease\n- Links:
      Underline slide from left (0.2s), color shift to accent\n- Cards:
      translateY(-4px) with shadow enhancement\n- Icons: 5° rotation or slight
      scale\n- Form fields: Border to accent on focus (0.2s)\n\nTypography:\n-
      Headline letter-spacing: -0.02em (tighter for impact)\n- Body
      letter-spacing: 0.01em (loose for readability)\n- Line length: 65
      characters max\n- No single-word line endings in headlines\n\nColor
      Application:\n- Base: 70% of visual space\n- Accent: Exclusively for
      conversion elements (CTAs, links, interactive states)\n- Trust
      backgrounds: Brand color at 5% opacity\n- Urgency elements: Warm accent at
      10% opacity for timers/limited offers\n\nDepth System:\n- Cards at rest:
      2px shadow\n- Hover: 8px shadow\n- Active/Modal: 24px shadow\n- Layered
      shadows: shadow-sm shadow-primary/10, shadow-md shadow-primary/5\n\nMOBILE
      OPTIMIZATION\n- Touch targets: 44x44px minimum\n- Thumb-zone: Primary CTAs
      bottom third of viewport\n- Single-column flow on 375px base\n- Test text
      overflow with long strings\n- No horizontal scroll\n- Sticky elements
      respect safe-area-insets\n\nCRITICAL REMINDERS\n1. Front-load important
      important content - users decide in 5 seconds\n2. Single dominant CTA per
      viewport section\n3. Restrained color palette (3 max + neutrals)\n4.
      Generous white space (80px padding) = premium perception\n5. Mobile-first
      with 44px touch targets\n\nGoal: Award-winning design that converts. Every
      design choice has strategic intent. Balance premium aesthetics with clear
      conversion strategy.\n\nStart building now.\n```\n\n---\n\n## PHASE 1:
      QUALITY CHECKLIST\n\nBefore outputting the prompt, verify:\n- [ ] Business
      context is specific (not generic)\n- [ ] Aesthetic anchor creates clear
      visual direction\n- [ ] All constraints are positive ("Use X" not "Avoid
      Y")\n- [ ] Measurements are specific (80px, 0.3s, 44x44px)\n- [ ]
      Conversion strategy embedded in each section\n- [ ] Industry trust signals
      identified\n- [ ] All provided image URLs integrated with placement
      strategy\n- [ ] Advanced Tailwind features requested\n- [ ] Mobile
      requirements include exact touch targets\n- [ ] Critical constraints
      appear at start AND end (primacy/recency)\n- [ ] Word count: 1,800-2,500
      words\n- [ ] NO meta-commentary - just the prompt itself\n\n---\n\n##
      PHASE 2: STRATEGY (Keep in Context, Don\'t Output Yet)\n\nWhen user
      requests "generate Phase 2 prompt", create enhancement prompt (1,800-2,500
      words):\n\n**Structure:**\n```\nEnhance the landing page with premium
      visual refinements:\n\nADVANCED ANIMATIONS (500 words)\n[Framer Motion
      implementations: scroll reveals, entrance sequences, parallax
      effects]\n[Specify variants, timing functions, stagger patterns, trigger
      conditions]\n\nMICRO-INTERACTIONS (400 words)\n[Button morphs, card
      reveals, cursor effects, loading sequences]\n[Precise timing, easing
      functions, hover choreography]\n\nCUSTOM ILLUSTRATIONS (300 words)\n[SVG
      elements, abstract shapes, brand-aligned graphics, icon
      systems]\n[Geometric patterns, organic shapes framing content]\n\nPREMIUM
      POLISH (400 words)\n[Textures, noise patterns, gradient systems,
      typography treatments]\n[3D perspective effects, glassmorphic layers,
      depth enhancements]\n\nINTERACTIVE STORYTELLING (400 words)\n[Scroll-based
      transitions, animated data visualizations, timeline
      progressions]\n[Before/after sliders, testimonial carousels, product
      showcases]\n\nMaintain core structure and conversion strategy. Focus
      exclusively on elevating visual sophistication to award-winning
      standards.\n```\n\n**Phase 2 reserves:**\n- Framer Motion scroll reveals
      with useInView\n- Magnetic buttons with cursor proximity\n- Staggered
      animations with orchestration\n- Custom cursor interactions\n- Animated
      gradient backgrounds\n- Kinetic typography\n- 3D card transforms on
      hover\n- Smooth page transitions\n- Progress indicators and loading
      states\n- Interactive data visualizations\n\n---\n\n## OUTPUT\n\nGenerate
      the complete Phase 1 Lovable.dev prompt now. Output ONLY the prompt  (max
      2600 words)- no explanations, no commentary, no meta-discussion.';


      console.log('Prompt:', prompt);


      const selectors = ['textarea', 'div[contenteditable="true"]',
      '[role="textbox"]'];

      let input = null;

      for (const sel of selectors) {
        const el = document.querySelector(sel);
        if (el && window.getComputedStyle(el).display !== 'none') {
          input = el;
          console.log('Found input:', sel);
          break;
        }
      }


      if (!input) {
        console.error('No input found');
        return { error: 'Input not found', success: false };
      }


      function setReactValue(element, value) {
        if (element.tagName === 'TEXTAREA') {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
          setter.call(element, value);
        } else {
          element.textContent = value;
        }
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }


      input.focus();

      await new Promise(r => setTimeout(r, 500));


      try {
        const success = document.execCommand('insertText', false, prompt);
        if (!success) {
          console.log('execCommand failed, using setReactValue');
          setReactValue(input, prompt);
        }
      } catch (e) {
        console.log('execCommand error:', e);
        setReactValue(input, prompt);
      }


      return { success: true, promptLength: prompt.length };
    param: paste3
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const buttonSelectors = [
        'button[type="submit"]',
        'button[aria-label*="Submit"]',
        'button[aria-label*="Send"]'
      ];


      for (const sel of buttonSelectors) {
        const buttons = Array.from(document.querySelectorAll(sel));
        for (const btn of buttons) {
          const style = window.getComputedStyle(btn);
          if (style.display !== 'none' && !btn.disabled) {
            console.log('Clicking submit button');
            btn.click();
            return { success: true, method: 'button' };
          }
        }
      }


      const input = document.querySelector('textarea, [contenteditable="true"],
      [role="textbox"]');

      if (!input) return { error: 'Input lost' };


      input.focus();


      const form = input.closest('form');

      if (form) {
        console.log('Submitting form');
        form.requestSubmit();
        return { success: true, method: 'form' };
      }


      console.log('Using Enter key');

      input.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        bubbles: true,
        cancelable: true
      }));


      return { success: true, method: 'keyboard' };
    param: submit3
  - type: say
    message: Waiting for Lovable Phase 1 prompt
  - type: wait
    timeout: 5000
    for: idle
  - type: js
    code: |
      const maxWait = 600;
      const check = 3;
      let waited = 0;
      while (waited < maxWait) {
        const stop = document.querySelector('button[aria-label*="Stop"]');
        const inputSelectors = ['textarea[placeholder="Ask anything..."]', 'textarea', 'div[contenteditable="true"]', '[role="textbox"]'];
        let input = null;
        for (const sel of inputSelectors) {
          input = document.querySelector(sel);
          if (input) break;
        }
        if (!stop && input) {
          return { finished: true, waitedSeconds: waited };
        }
        await new Promise(r => setTimeout(r, check * 1000));
        waited += check;
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: wait3
  - type: say
    message: Phase 1 prompt ready
  - type: say
    message: Extracting Phase 1 text
  - type: wait
    timeout: 2000
    for: idle
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 2000));

      let msgs = Array.from(document.querySelectorAll('div.prose'));

      if (msgs.length === 0) return '';

      return (msgs[msgs.length - 1].innerText || msgs[msgs.length -
      1].textContent || '').trim();
    param: phase1Prompt
  - type: say
    message: Phase 1 stored
  - type: wait
    timeout: 3000
    for: idle
  - type: say
    message: Prompt 4 - Phase 2 Enhancement
  - type: wait
    timeout: 3000
    for: idle
  - type: js
    code: >
      const prompt = 'Generate Phase 2 enhancement prompt for Lovable. CRITICAL:
      Output ONLY the prompt, no intro. First word Enhance. PHASE 2 FOCUS: NOT
      structure or content, page already built. ADD advanced visual refinements,
      sophisticated animations, premium polish, interactive elements. OPTIMAL
      1200-1800 words. Front-load impactful enhancements. FRAMEWORK: First 300
      tokens Enhance existing maintain structure focus visual. Positive Add X
      not Improve. Specific Implement parallax 0.5 speed. Exact timing 0.8s
      ease-out. CATEGORIES: ADVANCED ANIMATIONS 40 percent: Hero entrance
      headline 0.6s subhead delay 0.3s CTA 0.4s, background parallax gradient
      particle. Scroll Reveals stagger 0.1s delay translateY 40px to 0, scale
      0.9 to 1.0, trigger 80 percent viewport useInView. Section Transitions
      diagonal 5-7 degrees, fade crossfade, parallax 0.3-0.7 speeds.
      MICRO-INTERACTIONS 30 percent: Buttons hover scale 1.05 shadow 4-12px
      0.3s, active 0.95, ripple, icons slide 4px. Cards hover translateY -8px
      shadow, content reveal, border glow, tilt 2-3deg perspective. Forms focus
      border scale 1.02, label float, checkmark valid, shake error. Links
      underline slide 0.2s, color morph, icon rotate 5deg. VISUAL POLISH 20
      percent: Glassmorphic backdrop-blur-md semi-transparent, overlays modals.
      Gradients animated 3-5s cycles, mesh multiple stops, text fills. Textures
      noise 2-3 percent opacity, patterns low opacity, organic shapes. Shadows
      layered multiple, accent-tinted 15 percent, elevation 2px 8px 24px states.
      INTERACTIVE 10 percent: Scroll progress bar top fills, section highlights.
      Cursor custom magnetic trail. Loading skeletons progress optimistic.
      TECHNICAL: Framer Motion import motion useScroll useTransform useInView,
      variants sequences, useInView triggers, useScroll parallax. Performance
      transforms only never layout, motion-safe prefix, 60fps target. Timing
      fast 0.2-0.3s ease, medium 0.4-0.6s ease-in-out, slow 0.8-1.2s custom,
      stagger 0.1s delay. OUTPUT: Enhance existing maintain structure. ADVANCED
      ANIMATIONS hero scroll sections. MICRO-INTERACTIONS buttons cards forms
      links. VISUAL POLISH glass gradients textures shadows. INTERACTIVE
      progress cursor loading. TECHNICAL motion performance timing. REMINDERS
      maintain content structure brand 60fps motion-safe. Implement now.';


      console.log('Prompt:', prompt);


      const selectors = ['textarea', 'div[contenteditable="true"]',
      '[role="textbox"]'];

      let input = null;

      for (const sel of selectors) {
        const el = document.querySelector(sel);
        if (el && window.getComputedStyle(el).display !== 'none') {
          input = el;
          console.log('Found input:', sel);
          break;
        }
      }


      if (!input) {
        console.error('No input found');
        return { error: 'Input not found', success: false };
      }


      function setReactValue(element, value) {
        if (element.tagName === 'TEXTAREA') {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
          setter.call(element, value);
        } else {
          element.textContent = value;
        }
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }


      input.focus();

      await new Promise(r => setTimeout(r, 500));


      try {
        const success = document.execCommand('insertText', false, prompt);
        if (!success) {
          console.log('execCommand failed, using setReactValue');
          setReactValue(input, prompt);
        }
      } catch (e) {
        console.log('execCommand error:', e);
        setReactValue(input, prompt);
      }


      return { success: true, promptLength: prompt.length };
    param: paste4
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const buttonSelectors = [
        'button[type="submit"]',
        'button[aria-label*="Submit"]',
        'button[aria-label*="Send"]'
      ];


      for (const sel of buttonSelectors) {
        const buttons = Array.from(document.querySelectorAll(sel));
        for (const btn of buttons) {
          const style = window.getComputedStyle(btn);
          if (style.display !== 'none' && !btn.disabled) {
            console.log('Clicking submit button');
            btn.click();
            return { success: true, method: 'button' };
          }
        }
      }


      const input = document.querySelector('textarea, [contenteditable="true"],
      [role="textbox"]');

      if (!input) return { error: 'Input lost' };


      input.focus();


      const form = input.closest('form');

      if (form) {
        console.log('Submitting form');
        form.requestSubmit();
        return { success: true, method: 'form' };
      }


      console.log('Using Enter key');

      input.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        bubbles: true,
        cancelable: true
      }));


      return { success: true, method: 'keyboard' };
    param: submit4
  - type: say
    message: Waiting for Phase 2 prompt
  - type: wait
    timeout: 5000
    for: idle
  - type: js
    code: |
      const maxWait = 300;
      const check = 3;
      let waited = 0;
      while (waited < maxWait) {
        const stop = document.querySelector('button[aria-label*="Stop"]');
        const inputSelectors = ['textarea[placeholder="Ask anything..."]', 'textarea', 'div[contenteditable="true"]', '[role="textbox"]'];
        let input = null;
        for (const sel of inputSelectors) {
          input = document.querySelector(sel);
          if (input) break;
        }
        if (!stop && input) {
          return { finished: true, waitedSeconds: waited };
        }
        await new Promise(r => setTimeout(r, check * 1000));
        waited += check;
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: wait4
  - type: say
    message: Phase 2 prompt ready
  - type: say
    message: Extracting Phase 2 text
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 2000));

      let msgs = Array.from(document.querySelectorAll('div.prose'));

      if (msgs.length === 0) return '';

      return (msgs[msgs.length - 1].innerText || msgs[msgs.length -
      1].textContent || '').trim();
    param: phase2Prompt
  - type: say
    message: Phase 2 stored
  - type: wait
    timeout: 2000
    for: idle
  - type: say
    message: Returning to Perplexity
  - type: navigate
    url: https://lovable.dev
    waitForIdle: true
  - type: wait
    timeout: 8000
    for: idle
  - type: say
    message: Waiting for Lovable to load
  - type: js
    code: |
      const maxWait = 30;
      let waited = 0;
      while (waited < maxWait) {
        const input = document.querySelector('textarea#chatinput');
        if (input && !input.disabled) {
          return { ready: true, waitedSeconds: waited };
        }
        await new Promise(r => setTimeout(r, 1000));
        waited += 1;
      }
      return { ready: false, timeout: true };
    param: lovableReady
  - type: say
    message: Lovable ready - Pasting Phase 1
  - type: js
    code: >
      const text = args.phase1Prompt;

      console.log('Phase 1 length:', text.length);


      await new Promise(r => setTimeout(r, 2000));

      const input = document.querySelector('textarea#chatinput');

      if (!input) return { error: 'No input found' };


      input.focus();

      await new Promise(r => setTimeout(r, 1000));


      const nativeInputValueSetter =
      Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype,
      'value').set;

      nativeInputValueSetter.call(input, text);


      input.dispatchEvent(new Event('input', { bubbles: true }));

      input.dispatchEvent(new Event('change', { bubbles: true }));


      await new Promise(r => setTimeout(r, 500));


      const currentValue = input.value;

      console.log('Value after paste:', currentValue.substring(0, 100));


      return { success: true, length: currentValue.length, matches: currentValue
      === text };
    args: phase1Prompt
    param: lovablePaste1
  - type: wait
    timeout: 2000
    for: idle
  - type: say
    message: Submitting Phase 1
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const btn =
      document.querySelector('button#chatinput-send-message-button');

      if (!btn) {
        console.log('No button found');
        return { error: 'No button' };
      }


      if (btn.disabled) {
        console.log('Button is disabled');
        return { error: 'Button disabled' };
      }


      console.log('Clicking send button');

      btn.click();


      await new Promise(r => setTimeout(r, 1000));


      return { success: true };
    param: lovableSubmit1
  - type: say
    message: Waiting for Phase 1 generation
  - type: js
    code: |
      const maxWait = 600;
      let waited = 0;
      const checkInterval = 3;

      console.log('Starting wait for Lovable Phase 1 completion...');

      while (waited < maxWait) {
        await new Promise(r => setTimeout(r, checkInterval * 1000));
        waited += checkInterval;
        
        const thumbsUpButton = document.querySelector('svg.shrink-0.h-4.w-4[fill="currentColor"]');
        
        const textarea = document.querySelector('textarea#chatinput');
        const button = document.querySelector('button#chatinput-send-message-button');
        
        const textareaReady = textarea && !textarea.disabled;
        const buttonExists = !!button;
        const generationComplete = !!thumbsUpButton;
        
        if (generationComplete && textareaReady && buttonExists) {
          console.log('Lovable Phase 1 complete at', waited, 'seconds');
          console.log('Thumbs up button found:', generationComplete);
          console.log('Textarea ready:', textareaReady);
          return { finished: true, waitedSeconds: waited };
        }
        
        if (waited % 15 === 0) {
          console.log('Still generating...', waited, 'seconds elapsed');
          console.log('Thumbs up visible:', generationComplete);
          console.log('Textarea ready:', textareaReady);
        }
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: lovableWait1
  - type: say
    message: Phase 1 complete
  - type: wait
    timeout: 5000
    for: idle
  - type: say
    message: Pasting Phase 2
  - type: js
    code: >
      const text = args.phase2Prompt;

      console.log('Phase 2 length:', text.length);


      await new Promise(r => setTimeout(r, 2000));

      const input = document.querySelector('textarea#chatinput');

      if (!input) return { error: 'No input found' };


      input.focus();

      await new Promise(r => setTimeout(r, 1000));


      const nativeInputValueSetter =
      Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype,
      'value').set;

      nativeInputValueSetter.call(input, text);


      input.dispatchEvent(new Event('input', { bubbles: true }));

      input.dispatchEvent(new Event('change', { bubbles: true }));


      await new Promise(r => setTimeout(r, 500));


      return { success: true, length: input.value.length };
    args: phase2Prompt
    param: lovablePaste2
  - type: wait
    timeout: 2000
    for: idle
  - type: say
    message: Submitting Phase 2
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));

      const btn =
      document.querySelector('button#chatinput-send-message-button');

      if (!btn || btn.disabled) return { error: 'Button not ready' };

      btn.click();

      await new Promise(r => setTimeout(r, 1000));

      return { success: true };
    param: lovableSubmit2
  - type: say
    message: Waiting for Phase 2 generation
  - type: js
    code: |
      const maxWait = 600;
      let waited = 0;
      const checkInterval = 3;

      console.log('Starting wait for Lovable Phase 2 completion...');

      while (waited < maxWait) {
        await new Promise(r => setTimeout(r, checkInterval * 1000));
        waited += checkInterval;
        
        const thumbsUpButton = document.querySelector('svg.shrink-0.h-4.w-4[fill="currentColor"]');
        const textarea = document.querySelector('textarea#chatinput');
        const button = document.querySelector('button#chatinput-send-message-button');
        
        const textareaReady = textarea && !textarea.disabled;
        const buttonExists = !!button;
        const generationComplete = !!thumbsUpButton;
        
        if (generationComplete && textareaReady && buttonExists) {
          console.log('Phase 2 complete at', waited, 'seconds');
          return { finished: true, waitedSeconds: waited };
        }
        
        if (waited % 15 === 0) {
          console.log('Still generating Phase 2...', waited, 'seconds');
          console.log('Thumbs up visible:', generationComplete);
        }
      }
      return { finished: false, timedOut: true, waitedSeconds: waited };
    param: lovableWait2
  - type: say
    message: Phase 2 complete
  - type: wait
    timeout: 3000
    for: idle
  - type: say
    message: Extracting links
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 3000));


      const editor = window.location.href;

      console.log('Editor URL:', editor);


      let preview = '';


      const previewSvg = document.querySelector('svg.shrink-0.h-4.w-4[viewBox="0
      0 24 24"]');

      if (previewSvg) {
        let parent = previewSvg.parentElement;
        let attempts = 0;
        while (parent && attempts < 10) {
          if (parent.tagName === 'A' && parent.href) {
            preview = parent.href;
            console.log('Found preview via SVG parent:', preview);
            break;
          }
          parent = parent.parentElement;
          attempts++;
        }
      }


      if (!preview) {
        const allLinks = document.querySelectorAll('a[href]');
        for (const link of allLinks) {
          const title = link.getAttribute('title');
          const ariaLabel = link.getAttribute('aria-label');
          if (title && title.includes('preview') || ariaLabel && ariaLabel.includes('preview')) {
            preview = link.href;
            console.log('Found preview via tooltip:', preview);
            break;
          }
        }
      }


      if (!preview) {
        const allLinks = document.querySelectorAll('a[href]');
        for (const link of allLinks) {
          if (link.href && /preview.*\.lovable\.app/.test(link.href)) {
            preview = link.href;
            console.log('Found preview via URL pattern:', preview);
            break;
          }
        }
      }


      if (!preview) {
        const urlInput = document.querySelector('input#preview-url-bar');
        if (urlInput && urlInput.value) {
          const value = urlInput.value;
          if (value.startsWith('http')) {
            preview = value;
          } else {
            const baseLinkMatch = editor.match(/(https:\/\/[^\/]+)/);
            if (baseLinkMatch) {
              preview = value.startsWith('/') ? baseLinkMatch[1] + value : value;
            }
          }
          console.log('Found preview via input field:', preview);
        }
      }


      if (!preview) {
        preview = 'Preview link not found - check Lovable manually';
        console.log('Could not find preview link');
      }


      return { editorUrl: editor, previewUrl: preview, success: true };
    param: lovableLinks
  - type: say
    message: Links captured
  - type: wait
    timeout: 2000
    for: idle
  - type: say
    message: Returning to Perplexity
  - type: navigate
    url: '{{finalChatUrl}}'
    waitForIdle: true
  - type: wait
    timeout: 5000
    for: idle
  - type: say
    message: Sending data collection
  - type: wait
    timeout: 2000
    for: idle
  - type: js
    code: >
      const editor = args.lovableLinks.editorUrl;

      const preview = args.lovableLinks.previewUrl;

      const prompt = 'You are completing website redesign automation. Analysis
      and Lovable creation complete. Extract and format key data. LOVABLE LINKS:
      Editor ' + editor + ' Preview ' + preview + ' TASK: Generate single TSV
      row with 11 columns in exact order: 1. Business name 2. Lovable Editor
      Link 3. Lovable Preview 4. Date Germany timezone YYYY-MM-DD HH:MM 5.
      Business Type concise like Zahnarzt Restaurant Schreinerei 6. Email 7. Old
      Site Issues 2-3 point summary 8. Old Site Examples 1-2 concrete examples
      9. Old Site UI flaws visual interaction problems 10. Improvement potential
      high-impact opportunities 11. Benefits of improvements business outcomes.
      DATA SOURCES: Extract from conversation business intelligence extraction,
      design research, website assessment. FORMATTING: Single line fields
      separated by TAB, NO headers NO extra lines NO markdown around TSV, strip
      internal tabs newlines, max 200 chars per field, use NA only if unknown,
      place ONLY TSV in code block. QUALITY CHECKS: Exactly 11 fields, date
      Germany timezone, business type specific, examples concrete, single line
      only. OUTPUT: Return ONLY code block with single TSV row, no text before
      or after. Example structure: BusinessName TAB editor-url TAB preview-url
      TAB 2025-01-20 14:30 TAB Restaurant TAB email TAB issues TAB examples TAB
      flaws TAB improvements TAB benefits. Generate actual TSV row now using
      conversation data.';


      console.log('Prompt:', prompt);


      const selectors = ['textarea', 'div[contenteditable="true"]',
      '[role="textbox"]'];

      let input = null;

      for (const sel of selectors) {
        const el = document.querySelector(sel);
        if (el && window.getComputedStyle(el).display !== 'none') {
          input = el;
          console.log('Found input:', sel);
          break;
        }
      }


      if (!input) {
        console.error('No input found');
        return { error: 'Input not found', success: false };
      }


      function setReactValue(element, value) {
        if (element.tagName === 'TEXTAREA') {
          const setter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, 'value').set;
          setter.call(element, value);
        } else {
          element.textContent = value;
        }
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }


      input.focus();

      await new Promise(r => setTimeout(r, 500));


      try {
        const success = document.execCommand('insertText', false, prompt);
        if (!success) {
          console.log('execCommand failed, using setReactValue');
          setReactValue(input, prompt);
        }
      } catch (e) {
        console.log('execCommand error:', e);
        setReactValue(input, prompt);
      }


      return { success: true, promptLength: prompt.length };
    args: lovableLinks
    param: dataPrompt
  - type: js
    code: >
      await new Promise(r => setTimeout(r, 1000));


      const buttonSelectors = [
        'button[type="submit"]',
        'button[aria-label*="Submit"]',
        'button[aria-label*="Send"]'
      ];


      for (const sel of buttonSelectors) {
        const buttons = Array.from(document.querySelectorAll(sel));
        for (const btn of buttons) {
          const style = window.getComputedStyle(btn);
          if (style.display !== 'none' && !btn.disabled) {
            console.log('Clicking submit button');
            btn.click();
            return { success: true, method: 'button' };
          }
        }
      }


      const input = document.querySelector('textarea, [contenteditable="true"],
      [role="textbox"]');

      if (!input) return { error: 'Input lost' };


      input.focus();


      const form = input.closest('form');

      if (form) {
        console.log('Submitting form');
        form.requestSubmit();
        return { success: true, method: 'form' };
      }


      console.log('Using Enter key');

      input.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
        bubbles: true,
        cancelable: true
      }));


      return { success: true, method: 'keyboard' };
    param: dataSubmit
  - type: say
    message: AUTOMATION COMPLETE
version: 1
